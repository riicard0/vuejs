Aula 1: ===================================================================================================

Intro:

  Vue.js nada mais é do que um Javascript Progressivo (The Progressive JavaScript Framework), pois com 
  esse framework você consegue instalar pequenos componentes dentro do seu sistema antigo tanto quanto 
  num novo sistema. Resumindo, é um framework javascript para construir interfaces.

  Na camada "Model View Controller Arquitetura" o Vue.js se encaixa no "View" pois ele trabalha com a 
  interface, na camada "Model" e "Controller" é relacionada a back-end então envolve outros assuntos.

  No Vue.js:

	- Tudo é componente
	- Tudo é reativo
	- Super rápido


  Componente de arquivo único, exemplo:

	<template>
	  <div>
	    <h1 class="title">
	      {{ title }}
	    </h1>
	  </div>
	</template>

	<script>
	  export default{
	    name: 'MyComponent',

	    data() {
	      return {
		title: 'Hello World',
	      };
	    },

	    methods: {},
	  };
	</script>

	<style>
	  .title {
	    font-size: 20px;
	  }
	</style>

  Ou seja, sendo "Componente de Árquivo Único", a visualização é melhor, pois não é preciso abrir 
  vários arquivos para estilização ou script.

---------------------------------------------------------------------------------------------------

Diretivas:

  Condição e loops (v-if, v-else, v-else-if, v-for)
  Bind (v-bind)
  Two-way data binding (v-model)
  Eventos (v-on)
  Watchers
  ...

---------------------------------------------------------------------------------------------------

Dependências para conseguir assistir o curso:

  - Javascript Intermediário
  - HTML
  - CSS

---------------------------------------------------------------------------------------------------

Ecossistema:

  Vue Dev Tools
  Vue CLI
  Vue Router
  Vuex
  Vue Server Render

---------------------------------------------------------------------------------------------------

Para dar super poderes ao Vue.js podemos utilizar:

  Nuxt.js
  Quasar


Aula 2: ===================================================================================================

Documentação:

	https://vuejs.org/guide/introduction.html

---------------------------------------------------------------------------------------------------

Utilizar Vue.js através do CDN (without build tools):

  Dentro do "index.html" utilize:

	<head>

	  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

	</head>
	<body>

	  <div id="app">{{ message }}</div>

	  <script>
	    const { createApp } = Vue

	    createApp({
	      data() {
	        return {
	          message: 'Hello Vue 3!'
	        }
	      }
	    }).mount('#app')
	  </script>

	</body>

  Aqui já podemos utilizar o Vue.js normalmente.

  Porém se vamos começar um projeto do zero o melhor é utilizar o "Vue CLI" (with build tools), para 
  ver a documentação, acesse:

	https://cli.vuejs.org/guide/

---------------------------------------------------------------------------------------------------

Instalação NPM:

  Para instalar o "npm", dentro do VS Code utilizando o terminal com "Powershell", basta ir em:

	https://cli.vuejs.org/guide/installation.html

  E executar os comandos ordenados:

	npm install -g @vue/cli

  E depois, se precisar, fazer "update", no caso segui o que o próprio terminal indicou:

	npm install -g npm@9.2.0

  E por fim ver a versão em que está:

	npm --version

---------------------------------------------------------------------------------------------------

Política de Segurança do Windows 10 contra Scripts:

  No Windows 10, há uma política de segurança contra scripts que não forem assinados, 
  evitando que rode em sua máquina, para conseguirmos atuar sobre isso, rode dentro do Powershell, 
  lembrando que temos que executar o comando em "modo administrador":

	Set-ExecutionPolicy RemoteSigned -Scope LocalMachine

	y

  Caso queira obter o status antes de executar o comando acima, utilize:

	Get-ExecutionPolicy

  Para mais informações:

	https://pt.stackoverflow.com/questions/220078/o-que-significa-o-erro-execu%C3%A7%C3%A3o-de-scripts-foi-desabilitada-neste-sistema

---------------------------------------------------------------------------------------------------

Começo de tudo:

  Agora, após tudo isso, execute no terminal do VS Code com Powershell, lembrando de ter instalado na sua 
  máquina o "Node":

	vue create app

  O nome "app" quem cria é você. Escolha a opção do "Default ([Vue 3] babel, eslint)", ou seja, o Vue 3. 
  O próprio terminal te indicará os comandos, então:

	cd app

  Sobre os arquivos dentro desta pasta que foi criada pelo "Vue":

    - Não mexa em "node_modules", aqui existem todas as dependências para que nosso projeto possa 
    funcionar em ambiente de desenvolvimento.

    - A pasta "public" será aonde estarão os arquivos públicos, obviamente, onde estarão todos os arquivos 
    estáticos.

    - Na pasta "src" será onde a mágica irá acontecer de verdade. O arquivo "main.js" é o arquivo de 
    entrada dentro do "Vue.js". A pasta "Assets" onde ficarão as imagens, vídeo, css global, etc. Na 
    pasta "components" será onde ficarão nossos componentes.

    - Os outros arquivos que estarão isolados dentro da pasta criada, no caso "app", não precisaremos nos 
    preocupar no momento. Existe somente um que é o "vue.config.js" que será onde ocorrerão algumas 
    configurações especiais caso precise no nosso projeto.

  Através do CDN utilizamos um link dentro do HEAD do HTML para instanciarmos o "Vue.js", aqui rodaremos 
  um comando no terminal, que também foi indicado pelo próprio terminal:

	npm run serve

  Assim, acabamos de ligar um servidor local para desenvolvimento da nossa aplicação.

  No caso, ocorreu um erro no terminal:

	ERROR in Conflict: Multiple assets emit different content to the same filename index.html

  Consegui arrumar tirando o HTML da pasta "public" e colocando dentro da própria pasta "app" (raiz do 
  projeto), depois a aplicação rodou normalmente.

Aula 3: ===================================================================================================

Componentes de arquivo único SFC:

  Single File Component (Componente de Arquivo Único) ou SFC.

  Todos os componentes que criarmos tem que ter a extensão ".vue". Por exemplo, no arquivo que foi criado 
  chamado "app.vue" na primeira camada dentro dele temos o nosso HTML, na segunda camada o Javascript e 
  por último temos a camada do CSS. Exatamente por isso tem esse nome "SFC", pois em um único arquivo 
  temos as três camadas necessárias.

  Dentro da pasta "components", que está dentro de "src", vamos criar nossos "components", como exemplo:

	TheHeader.vue

  Não colocaremos somente "Header.vue" pois já temos um elemento HTML chamado "header" e isso criaria 
  conflitos. Então evite criar nomes de componentes que sejam iguais a nomes de elementos HTML.

---------------------------------------------------------------------------------------------------

Módulos (import/export):

  Módulos Javascript nada mais é do que exportar funcionalidades e importar funcionalidades. Ou seja, 
  por exemplo, eu possuo dois arquivos ".js" ("main.js" e o "superHero.class.js"), digamos, dentro do 
  segundo arquivo vamos deixar diversas funcionalidades lá dentro, como funções, métodos, classes, etc. e 
  dentro do primeiro arquivo "main.js" importaremos somente o necessário no momento para que possamos 
  trabalhar de forma dinâmica e confortável.

  Tipos:

	export default nomeVariavel;

	import nomeVariavel from 'arquivo.js';

  ou

	export function user() {};

	import { user } from 'script.js';

---------------------------------------------------------------------------------------------------

  Para importarmos, temos de ir dentro de "script" e "template" no arquivo "app.vue", lembresse dessa 
  sequência:

	import
	components
	template

  Ou seja, iremos instanciar o arquivo externo primeiro dentro da tag "script" com o "import", depois 
  chamá-lo dentro de "components" e por último chamá-lo dentro da tag "template".

  Na prática:

	<template>

	  <HelloWorld />

	</template>

	<script>

	  import HelloWord from './components/HelloWorld';

	  export default {
	    name: 'App',
	    components: {
	      HelloWorld
	    }
	  }

	</script>

  Assim

  O que estou dizendo, primeiro instanciaremos o "HelloWorld.vue" com "import" dentro da tag "script", 
  depois instanciaremos no "export" (dentro da propriedade "components") e também instanciaremos dentro 
  da tag "template" uma tag de mesmo nome, no caso "HelloWorld". Um complementa o outro, pois faltando 
  algum deles o EsLint é bem chato e ficará acusando erro atrás de erro.

Aula 4: ===================================================================================================

Declarações condicionais (diretiva v-if v-show):

  Tudo que é iniciado no Vue.js com "v-" é chamado de "diretiva".

	v-show
	v-if
	v-else-if
	v-else

  Dentro do arquivo "App.vue" em "export" temos também, além dos campos citados, o campo "data" que é uma 
  função que retorna um objeto.

  Lembrando que temos um outro arquivo que criamos chamado "TheHeader" para que isso possa funcionar.

	<template>
	  <TheHeader v-show="showHeader"  />
	</template>

  Acima temos uma variável dentro de "v-show".

	export default {
	  name: 'App',
	  components: {
	    HelloWorld,
	    TheHeader
	  },
	  data() {
	    return {
	      showHeader: false
	    }
	  }
	}

  É através desse objeto que estamos manipulando aquela variável.

  O "v-show" e "v-if" são muito parecidos, porém a diferença é que o "v-show" é basicamente o "display" do 
  "CSS" enquanto o "v-if" continua sendo uma "declaração condicional" se estivessemos em Javascript, por 
  exemplo. 

  Observações:

	- O "v-if" ocupa bem mais memória de processamente do que o "v-show", porém com ele podemos 
	utilizar o "v-else-if" e "v-else".

	- Ficar alerta, pois o "Vue.js" quando se utiliza do "v-show" e utilizamos um "false", como no 
	exemplo citado anteriormente, ele somente adiciona um "display: none" a tag, no código fonte da 
	aplicação, porém a tag ainda continua a aparecer.

	- Caso você queira que essa tag suma por questões de segurança, temos de utilizar o "v-if", pois 
	quando a tag é tida como "false", ou o "v-else-if" ou "v-else", é utilizado aquele "v-if" some 
	completamente do código fonte da aplicação.

  Outro exemplo:

	<template>
	    <div v-show="showName">
	      Nome: {{ firstName }} 
	      <br>
	      Sobrenome: {{ lastName }}
	      <br>
	      Nome completo: {{ firstName + ' ' + lastName }}
	    </div>
	</template>

	export default {
	  name: 'App',
	  components: {
	    HelloWorld,
	    TheHeader
	  },
	  data(){
	    return {
	      showHeader: false,
	      firstName: 'Jon',
	      lastName: 'Snow',
	      showName: true
	    }
	  }
	}

  Para dizermos ao Vue.js que algo dentro de "<template>" é uma variável, utilizamos a interpolação 
  "{{  }}"

  Com isso também vimos que podemos manipular os elementos da página através de um novo arquivo criado, 
  como o foi o "TheHeader", ou também pelo próprio "App.vue" e dentro de "App.vue" podemos manipular tanto 
  arquivos externos que importamos para cá, como o foi o "TheHeader" colocando "v-show" sobre ele, quanto 
  novos elementos que queremos adicionar diretamente.

  E para exemplificar o "v-if" na prática:

	<template>
	  <div v-if="accessLevel === 'admin'">Administrador</div>
	  <div v-else-if="accessLevel === 'marketing'">Marketing</div>
	  <div v-else>Current User</div>
	</template>

	export default {
	  name: 'App',
	  components: {
	    HelloWorld,
	    TheHeader
	  },
	  data(){
	    return {
	      accessLevel: ''
	    }
	  }
	}
	</script>

Aula 5: ===================================================================================================

Instruções de loops (diretiva v-for):

  No site:

	https://jsonplaceholder.typicode.com/

  Temos uma ajuda com JSON para "Fake API". Para pegar uma lista de "to do":

	https://jsonplaceholder.typicode.com/todos?_limit=5

  Mudando o final do endereço do site alteramos o tanto de "to do" que queremos.

  Exemplo:

	<template>
	  <div>
	    <div 
	      v-for="(obj, index) in todos"
	      v-bind:key="obj.id"
	      class="todos-item"
	    >
	      {{ index+=1 }} - {{ obj.title }}
	    </div>
	  </div>
	</template>


	export default {
	  name: 'App',
	  components: {
	    HelloWorld,
	    TheHeader
	  },
	  data(){
	    return {
	      todos: [
	        {
	          "userId": 1,
	          "id": 1,
	          "title": "delectus aut autem",
	          "completed": false
	        },
	        {
	          "userId": 1,
	          "id": 2,
	          "title": "quis ut nam facilis et officia qui",
	          "completed": false
	        },
	        {
	          "userId": 1,
	          "id": 3,
	          "title": "fugiat veniam minus",
	          "completed": false
	        },
	        {
	          "userId": 1,
	          "id": 4,
	          "title": "et porro tempora",
	          "completed": true
	        },
	        {
	          "userId": 1,
	          "id": 5,
	          "title": "laboriosam mollitia et enim quasi adipisci quia provident illum",
	          "completed": false
	        }
	      ]
	          }
	        }
	      }
	</script>


	<style>
	.todos-item {
	  background: #000;
	  margin: 0 0 5px 0;
	  padding: 3px 6px;
	  color: #fff;
	}
	
	#app {
	  font-family: Avenir, Helvetica, Arial, sans-serif;
	  -webkit-font-smoothing: antialiased;
	  -moz-osx-font-smoothing: grayscale;
	  color: #2c3e50;
	  margin: 60px;
	}
	</style>

  Ou seja, a estrutura "v-for" se dará:

	v-for"*NOME DA INSTRUÇÃO* in *NOME DA VARIÁVEL*"

  Na prática:

	v-for="obj in arr"

  Como no exemplo, também lembro que podemos utilizar mais de uma instrução, ou seja:

	v-for="(obj, index) in arr"

  O "v-bind" iremos estudá-lo mais a frente, mas no caso pegamos os "id" compostos pelo "JSON" 
  utilizando-o dentro de uma "key".

  O "index" passado nada mais é do que o índice dos elementos do "JSON", porém adicionei um número a mais, 
  já que os índices começam no número 0, para lista ficar mais organizada.

Aula 6: ===================================================================================================

Atributos Dinâmicos com data binding (diretiva v-bind):

  A diretiva "v-bind" é um atributo dinâmico, ou seja, todo valor passado para ela terá de ser dinâmico.

  A diretiva "v-bind" é no formato "One-Way data binding", ou seja, temos a possibilidade de alterar o 
  valor somente pelo sistema.

	<template>
	 <div>
	    <img 
	      v-bind:src="imgSrc"
	      v-bind:alt="imgAlt"
	    >
	  </div>
	</template>

	<script>
	import HelloWorld from './components/HelloWorld.vue'
	import TheHeader from './components/TheHeader';

	export default {
	  name: 'App',
	  components: {
	    HelloWorld,
	    TheHeader
	  },
	  data(){
	    return {
	      imgSrc: 'https://via.placeholder.com/150',
	      imgAlt: 'Foto de Jon Snow'
	          }
	        }
	      }
	</script>

  Imagine, por exemplo, seguindo o exemplo acima, que a imagem vem de uma "API" e o "Alt" venha do banco 
  de dados, ou seja, dinamicamente.

  Existe uma forma de declarar o "v-bind" que acaba por deixar o código mais limpo, que é somente 
  declarando o ":". Olha a dirença do exemplo anterior para agora:

  Exemplo anterior:

	v-bind:alt="imgAlt"

  Novo exemplo:

	:alt="imgAlt"

  O "Vue.js" identifica que estamos chamando o "v-bind" então o declara. Claramente que o valor que irá 
  dentro das aspas é uma variável.

Aula 7: ===================================================================================================

Atributos Class e Style dinâmicos:

  Exemplo:

	<template>
	  <div>
	    <h1 :class="classVar">Curso Vue 3</h1>
	  </div>
	</template>

	<script>
	  export default {
	    name: 'App',
	    components: {
	    },
	    data(){
	      return{
		  classVar: 'title'
		}
	    }
	</script>

	<style>
	  .title{
	    font-size: 20px;
	    color: blue;
	  }
	</style>

  Dessa forma chamamos uma "Class" dinamicamente.

  Lembrando que no valor da "v-bind" podemos utilizar:

	{}
	[]
	['', '', {}]

  Ou seja, objetos, arrays e caso queira arrays com objetos também.

  Outro exemplo:

	<h1 :class="{ 'title': true }">Curso Vue 3</h1>

  Esse "true" que está como valor do "v-bind" pode ser trocado por alguma outra coisa dinâmica.

  Outro exemplo:

	<h1 :class="{ 'title': true, 'title-home': isHome }">Curso Vue 3</h1>

  Outro exemplo:

	  <p :class="['text', 'title', { 'text-home': isHome }]">
	    Lorem ipsum, dolor sit amet consectetur adipisicing elit.
	  </p>

  Ou seja, podemos também passar múltiplos campos dentro do valor do "v-bind".

---------------------------------------------------------------------------------------------------

Agora exemplo com o "style":

  No "template":

	 <p :style="styleClass">
	  Lorem, ipsum dolor sit amet consectetur adipisicing elit. Ratione, quia?
	 </p>

  No "script":

	data(){
	  return{
	    styleClass: { 'color': 'aqua', 'background-color': 'black' }
	  }
	}

Aula 8: ===================================================================================================

Ligação de Dados Bidirecional (diretiva v model):

  A diretiva "v-model", diferente da "v-bind", é no formato "Two-Way data binding", ou seja, temos a 
  possibilidade de alterar o valor tanto pelo sistema (back-end) quanto pelo usuário (front-end).

	<template>
	  <div>
	    <label>Nome:</label>
	    <br>
	    <input v-model="name" type="text">
	    <br>
	    {{ name }}
	  </div>
	</template>

	<script>
	  export default {
	    name: 'App',
	    data() {
	      return {
	        name: 'Jon Snow',
	      }
	    }
	  }
	</script>

  Ele funciona praticamente como o "v-bind" na escrita, porém utiliza do conceito de "Two-Way data 
  binding" como dito anteriormente. Funciona muito bem com formulários:

	<template>
	  <div>
	    <label>Sports:</label>
	    <br>
	    <select v-model="sports">
	      <option value="">Escolha</option>
	      <option value="Futebol">Futebol</option>
	      <option value="Skate">Skate</option>
	      <option value="Tenis">Tenis</option>
	    </select>
	    <br>
	    {{ sports }}
	  </div>
	</template>

	<script>
	  export default {
	    name: 'App',
	    data() {
	      return {
	        name: 'Jon Snow',
	        sports: '',
	      }
	    }
	  }
	</script>

Aula 9: ===================================================================================================

Eventos:

  Lembro que Vue.js é Javascript, então podemos capturar todo evento que quisermos.

  Agora iremos trabalhar com a diretiva "v-on", ela é a que captura o evento desejado. A sintaxe dela é 
  chamar a diretiva, depois o evento desejado, e o valor, que no exemplo abaixo será uma função:

	<button v-on:click="onClick">
	  Enviar
	</button>

  Assim como no "v-bind" que podemos chamar o ":" ao invés do comando inteiro, economizando código e 
  deixando melhor indentado, no "v-on" podemos utilizar o "@" que o "Vue.js" reconhece que estamos 
  chamando essa determinada diretiva.

	<button @click="onClick">
	  Enviar
	</button>

  Lembrando que no "script", as funções sempre ocorrerão dentro de um novo campo, chamado "methods".

---------------------------------------------------------------------------------------------------

Existem os "modificadores de eventos":

	https://br.vuejs.org/v2/guide/events.html#Modificadores-de-Evento

  Bom, existem alguns modificadores de eventos como sufixo para a diretiva "v-on":

  - Esse sufixo modificador de evento interrompe a propagação do evento:

	.stop

  - Previne de carregar o evento:

	.prevent

  - Usar modo de captura ao adicionar o evento:

	.capture

  - Só aciona o evento caso o "event.target" seja o próprio elemento, ou seja, o elemento pai:
  
	.self

  - Só aciona o evento uma vez:

	.once

  - Comunica ao navegador que você não quer prevenir o comportamento padrão do evento. O ".passive" é 
  especialmente útil para otimizar desempenho em dispositivos móveis:

	.passive

  Lembrando que modificadores podem ser encadeados, exemplo:

	<a @click.stop.prevent="doThat"></a>

  A ordem importa ao utilizar modificadores pois o código relevante é gerado na mesma ordem. Desta forma:

	@click.prevent.self 

  prevenirá todos os cliques, enquanto:

	@click.self.prevent 

  prevenirá apenas cliques no próprio elemento.

  Não use ".passive" e ".prevent" juntos, pois ".prevent" será ignorado e seu navegador provavelmente 
  exibirá um aviso. Lembre-se, ".passive" comunica ao navegador que você não quer prevenir o 
  comportamento padrão do evento.

  Existem também as "Key Codes", que são sufixos modificadores de eventos que ocorre quando você fizer 
  determinado ação para com o teclado, exemplo:

	https://br.vuejs.org/v2/guide/events.html#Key-Codes

  - O evento só ocorrerá a partir do momento que "enter" for pressionado:

	.enter

  Último exemplo de modificador de evento:

	<template>
	  <div>

	    <form 
	      action="https://google.com" 
	      @submit.prevent.once="onSubmit"
	    >

	      <input 
	        type="text"
	        @keyup.enter="onKeyUp"
	      >

	      <button type="submit">Enviar</button>

	    </form>

	  </div>
	</template>

	<script>
	  
	  export default {
	    name: 'App',

	    data() {
	      return {
	
	      }
	    },

	    methods: {
	      onSubmit() {
	        console.log('submit');
	      },
	      onKeyUp() {
	        console.log('onKeyUp');
	      }
	    }
	  }

	</script>

Aula 10: ==================================================================================================

Propriedade Computada (computed):

  Propriedade computada é quando você quer montar um valor, baseado em outros valores, ou seja, um valor 
  final vindo de outros valores. Para isso teremos agora um novo campo em "export" chamado "computed", 
  esse campo é o que fará a propriedade computada, exemplo:

	<template>
	  <div>
	    {{ fullName }}
	  </div>
	</template>

	<script>
	export default {
	  name: 'App',
	  components: {
	
	  },
	  data() {
	    return {
	      user: {
	        first_name: 'Jon',
	        last_name: 'Snow'
	      }
	    }
	  },
	  computed: {
	    fullName() {
	      return `${this.user.first_name} ${this.user.last_name}`
	    }
	  },
	  methods: {
	
	  }
	}
	</script>

  Ou seja, dentro de "export" na tag "script", criamos o objeto "user" e adicionamos duas propriedade, no 
  campo "computed" criamos uma função que juntará essas propriedades criadas anteriormente, utilizando de 
  "template string". Para chamar elas utilizamos o "this". Depois para aparecer no nosso código, lá na tag 
  "template", continua sendo a mesma coisa.

  A vantagem disso é que o "Vue.js" irá processar isso de uma maneira bem mais rápida e será recomputado 
  toda vez que alterarmos qualquer valor internamente.

---------------------------------------------------------------------------------------------------

Colocar "Vue.js" numa variável global:

	Vá em "main.js" e na linha com o seguinte código:

		createApp(App).mount('#app')

	Adicione antes:

		window.app = 

	Ficando assim:

		window.app = createApp(App).mount('#app')

	Agora podemos consultar o "Vue.js" do próprio console do navegador pela variável global "app".

---------------------------------------------------------------------------------------------------

Diferença entre "computed" e "methods":

  Caso agora formos no console do navegador e alterarmos o valor de alguma dessas propriedades de "user" 
  que criamos, o valor será alterado e recomputado na hora.

  A diferença do campo "computed" para o campo "methods" é que no campo "methods" o sistema ficará 
  recomputando a função toda hora, gastando assim mais memória, já no campo "computed" já está "cacheado" 
  (cache), ou seja, só irá recomputar novamente quando alguns dos valores forem alterados.

  Por isso é mais recomendado o "computed" quando você tem que fazer o valor final dependente de outros 
  valores.

Aula 11: ==================================================================================================

Observadores (watch):

  O observador é o "watch", esse observador será um novo campo dentro de "export" da tag "script" que 
  trabalhará, claramente, observando tudo que acontece dentro do código avisando assim ao "Vue.js" dentro 
  de determinadas obrigações impostas a ele por você.

	export default {
	  name: '',
	  watch: {
	    ...
	  }
	}

  Ele funciona com função, exemplo:

	watch: {
	  pageCount() {
            this.changePage();
          }
	},
	methods: {
	  changePage() {
            console.log('Ajax changePage');
          }
	}

  Nesse caso criamos uma função qualquer chamada "pageCount" e em "methods" criamos uma outra função no 
  qual será observado.

  Ele funciona com objeto, exemplo:

	data(){
	  return {
	    user: {
	      first_name: '',
	      last_name: ''
	    }
	  }
	},
	watch: {
	  user: {
            handler() {
              console.log('User alterado');
            },
            deep: true
          }
	}

  Aqui no caso, temos o "watch" observando a variável "user" e suas propriedades, através da função 
  "handler" que dirá que quando tal variável se alterar execute tal instrução, ou seja, no nosso caso, 
  quando "user" se alterar execute o "console.log" e o "deep" com valor "true" diz que quando qualquer 
  coisa dentro da variável "user" se alterar, dispare a função, ou seja, uma observação aprodundada, quer 
  dizer que agora ele está observando profundamente, não somente na parte rasa.

  Lembrando que o watch chamado tem que ser o mesmo nome da variável que quiser observar.

Aula 12: ==================================================================================================

Ciclo de Vida (life cicle):

  As fases do ciclo de vida do componente "Vue.js" são divididas em quatro:

    - Criação:
	você prepara o componente. Exemplo: Ajax, inicializar algumas variáveis; Não tem acesso ao 
	template (DOM).

    - Montagem:
	Inicializar uma lib externa, geralmente precisa de acesso ao template (DOM); Tem acesso ao 
	template (DOM).

    - Atualização:
	Geralmente é mais utilizado para "debug"; Update.

    - Desmontagem:
	Remover tudo o que for necessário para liberar memória.

  Para interagirmos com essas fases, temos o que é chamado de "Hooks", sendo eles:

	beforeCreate(){}	- Antes do componente ser criado.

	Created(){}		- Componente foi criado.

	beforeMount(){}		- Antes do componente ser montado.

	Mounted(){}		- Componente foi montado.

	beforeUnmount(){}	- Antes do componente ser desmontado.

	Unmounted(){}		- Componente foi desmontado.

  Todos essas funções serão feitas dentro da tag "script" em "export default".

  Quando você cria, por exemplo, uma variável dentro de "data()", você só poderá ter acesso a ela depois 
  de "created()", antes disso, em "beforeCreate()" não será possível acessá-la.

  Ou seja, você só terá acesso ao "estado do componente" de "created()" pra frente.

  Terá acesso ao DOM de "mounted()" pra frente.

  No "Vue.js" temos um atributo especial chamado "$el" que dá acesso ao DOM, ou seja, o "$el" puxa o 
  elemento raiz do componente.

  É no "beforeUnmount()" que iremos destruir nossas libs, eventos, listeners.

  Também não podemos nos esquecer da "Atualização" que será setada com:

	beforeUpdate(){}

	Updated(){}

  Então neles, tudo que acontecer no componente irá disparar nesses dois, ou seja, imagine que você faça 
  alguma alteração no front dentro de um "input", o "beforeUpdate()" e o "updated()" irão acionar dizendo 
  que houve atualização. Porém esse recurso não será tão utilizado, é mais para "debug".

Aula 13: ==================================================================================================

Components Slots:

  Serve para deixar nosso componente mais flexível ainda, exemplo se eu colocar a tag slot dentro de um 
  componente, exemplo "TheHeader.vue":

	<template>
	  <slot />
	</template>

  Dentro do arquivo "App.vue" ao criar a tag do componente, poderemos modificá-lo conforme quisermos o 
  arquivo "TheHeader.vue" através daquela tag, ou seja, injetar algo que irá manipular o componente, 
  criando agora, ao invés de:

	<TheHeader />

  Agora teremos uma tag completa dentro de "App.vue":

	<TheHeader>
	  ...
	</TheHeader>

  Temos também o "named slot", ou seja, slots nomeados que facilita na manipulação do componente ainda 
  mais. Exemplo:

  Arquivo "TheHeader.vue":

	<template>
	    <!-- Conteúdo "Title" -->
	    <h1 class="title">
	      <slot name="title" />
	    </h1>

	    <!-- Conteúdo "Description" -->
	    <div class="description">
	      <slot name="description" />
	    </div>

	    <!-- Conteúdo "Default" -->
	    <div class="content ">
	      <slot />
	    </div>
	</template>


  Arquivo "App.vue":

	<TheHeader>
	  <template v-slot:title>
	    Title
	  </template>

	  <template v-slot:description>
	    <h2>Description</h2>
	  </template>

	  Default Slot
	</TheHeader>


  "Slot" não nomeados se tornam "default".

  E agora aprendemos mais um diretiva, a diretiva "v-slot" no qual manipula as "named slot".

  Essa injeção de dados, ou manipulação, quando inspecionada na página do navegador, aparece tudo como se 
  estivéssemos escrito o código no próprio "index" e não injetado através de outro arquivo.

  Lembrando que na hora de chamar o "named slot" temos de setar a tag "template" com a diretiva "v-slot".

  Já aprendemos que temos acesso ao elemento através do "mounted()", ou seja:

	export default {
	  mounted(){
	    console.log( this.$el );
	  }
	}

  Ou seja, acesso ao "$el". Lembrando apenas que esse componente é do "template" do componente e não do 
  projeto inteiro, não. Ou seja, você conseguirá manipular somente esse bloco de informação dentro desse 
  componente.

  Agora também temos acesso ao:

	export default {
	  mounted(){
	    console.log( this.$slots );
	  }
	}

  Agora temos acesso ao "$slots" através do "mounted()". E como podemos utilizar isso?

  Na prática, o arquivo "App.vue":

	<TheHeader>
	  // <template v-slot:title>
	  //  Title
	  // </template>

	  <template v-slot:description>
	    <h2>Description</h2>
	  </template>

	  Default Slot
	</TheHeader>

  Ou seja, comentei o "title" então ele está inexistente nesse caso, não aparecerá setado.

  O arquivo "TheHeader.vue":

	<template>
	    <!-- Conteúdo "Title" -->
	    <h1 v-if="$slots.title" class="title">
	      <slot name="title" />
	    </h1>

	    <!-- Conteúdo "Description" -->
	    <div class="description">
	      <slot name="description" />
	    </div>

	    <!-- Conteúdo "Default" -->
	    <div class="content ">
	      <slot />
	    </div>
	</template>

  Ou seja, adicionamos a diretiva "v-if" indicando aquele "$slots", sendo ele um objeto, dizendo que se 
  for "true" poderá executar, caso for "false", como o é agora, sendo que comentamos o código lá no 
  "App.vue", ele não reconhecerá o comando e ocultará no inspecionamento da página (dentro do navegador).

  Apenas aparecerá de forma comentada na inspeção de página:

	<!-- v-if --> == $0

  Obsevação, deixei o "title" comentado só para ilustrar como se eu não tivesse declarado ele no arquivo, 
  ou seja, como se ele não tivesse setado lá.

  Isso tudo sobre "slot" é um recurso muito poderoso no "Vue.js" e iremos utilzar demais nos nossos 
  projetos.


Aula 14: ==================================================================================================

Scoped e Global CSS:

  Na tag "script", dentro de "import" podemos utilizar o "@", que é chamado de "alias" para achar o 
  caminho de determinado arquivo, exemplo:

  Antigamente:

	import BaseCard from '../../components/BaseCard.vue';	

  Agora:

	import BaseCard from '@/components/BaseCard.vue';

  Ou seja, o Vue CLI facilita nossa vida apenas passando o "alias", é uma forma curta para dizermos que 
  estamos dentro de "src", pasta do projeto "Vue.js", é um atalho.

  Depende de qual esteja configurado, mas alguns desenvolvedores gostam de utilizar o "~".

---------------------------------------------------------------------------------------------------

  - CSS GLOBAL:

  Para criarmos um "CSS Global", na pasta "assets" agora criaremos uma pasta chamada "css" e um arquivo 
  dentro dela chamado "style.css". Esse é o arquivo de "CSS Global".

  Para chamarmos esse "CSS Global", iremos em "main.js" e em "import":

	import '@/assets/css/style.css';

  O ponto negativo de utilizar essa forma de injetar CSS na página é que toda vez que carregar a aplicação 
  esse arquivo de CSS irá carregar junto, então dessa maneira você pode estar injetando CSS na página sem 
  ter necessidade.

  - CSS LOCAL:

  A forma de declarar o "CSS Local" é através do arquivo ".vue", como já vimos anterior, para exemplo 
  criamos um arquivo novo chamado "BaseCard.vue":

	<template>
	  <div class="card">
	    Lorem Ipsum dolor sit amet consectetur adipisicing elit.
	  </div>
	</template>

	<style>
	  .card{
	    background-color: #000;
	    color: #fff;
	  }
	</style>

  Porém, se agora fôssemos para o arquivo "App.vue" e importássemos esse arquivo "BaseCard.vue" para lá, 
  que tem uma classe no CSS chamada ".card", e lá no arquivo "App.vue" utilizássemos uma classe com esse 
  mesmo nome em outro elemento criaria um conflito e essa mesma classe seria utilizada lá, sendo que no 
  caso iremos querer classe de mesmo nome porém com instruções diferentes para cada arquivo. Ou seja, 
  a classe ".card" do arquivo "BaseCard.vue" ficará digamos que como global.

  E é aí que entra o "Scoped".

  - CSS SCOPED:

  É simples o modo de utilizar o "CSS Scoped", somente temos que ir no arquivo que criamos recentemente, 
  exemplo que estamos utilizando é o "BaseCard.vue" e na tag "style" setar o "scoped":

	<style scoped>
	  ...
	</style>

  Assim, classe de mesmo nome no arquivo "App.vue" não criarão mais conflitos e cada uma terá as suas 
  instruções específicas.

  Ou seja, no momento é a melhor forma de declarar CSS que podemos utilizar. Prefira sempre utilizar 
  dessa maneira a partir de agora em diante.

Aula 15: ==================================================================================================

Enviando Dados Para o Componente Filho (props):

  Vamos criar um componente de alerta para exemplificar: "BaseAlert.vue"

  Para questão de boas práticas no "Vue.js" ao criar um componente novo, utilizasse "Base" como prefixo 
  do nome do arquivo caso o arquivo seja um componente de visualização, ou seja, colocasse um prefixo 
  para identificar mais facilmente caso o projeto acabe ficando grande e precise alterar algo, exemplo:

	BaseAlert.vue
	BaseCard.vue
	BaseButton.vue

---------------------------------------------------------------------------------------------------

  Uma das formas de utilizarmos o "props":

	<template>
	  <div :class="['alert', {
	    'alert-success': variant === 'success',
	    'alert-danger': variant === 'danger'
	  }]">
	    Seu formulário foi enviado com sucesso!
	  </div>
	</template>




	<script>
	export default {
	  props: ['variant']
	}
	</script>




	<style scoped>
	.alert {
	  padding: 5px;
	  border-radius: 6px;
	  color: gray;
	  background-color: #ddd;
	}
	
	.alert-success {
	  background-color: #42b983;
	  color: #fff;
	}
	
	.alert-danger {
	  background-color: red;
	  color: #fff;
	}
	</style>

  Lembrando que esse é um novo componente que criamos chamado "BaseAlert.vue".

  Ou seja, na tag "template", pegamos uma "div", chamamos "class" guiada por um "bind" adicionando um 
  "array" com a classe "alert", "alert-success" e "alert-danger".

  Na tag "script" criamos a "props" chamando ela de "variant".

  Na tag "template" novamente, setamos como valor de "alert-success" e "alert-danger" com a "variant" e 
  uma declaração condicional perguntando "se for igual a tal execute tal".

  Na tag "style" estilizamos as classes.

  Agora no arquivo "App.vue", importaremos esse componente "BaseAlert.vue", setando ele e chamando agora 
  a "variant" desejável:

	<div>
	  <BaseAlert variant="danger" />
	</div>

  Se você tiver muitas "variant" o código dentro de "BaseAlert.vue" ficará muito poluído, então há uma 
  forma de realizarmos a mesma tarefa de forma mais simples. 

  Onde era:

	<template>
	  <div :class="['alert', {
	    'alert-success': variant === 'success',
	    'alert-danger': variant === 'danger'
	  }]">
	    Seu formulário foi enviado com sucesso!
	  </div>
	</template>

  Agora ficará:

	<div :class="`alert alert-${variant}`">
	  Seu formulário foi enviado com sucesso!
	</div>

  Veja como o código ficou bem mais limpo e realizando de forma tão eficaz quanto anteriormente.

  Aqui, continuamos utilizando o "bind" no "class", e como valor inserimos um "template string" com a 
  classe "alert" e "alert-" obtendo essa última um valor flexível, ou seja, da "props", então 
  "alert-${...}". O valor flexível da "props" como criamos anteriormente é a "variant".

  Nessa forma o código ficará bem mais limpo, porém na hora de inspecionar o site, a classe como tem fixo 
  "alert-", quando não existir valor para ela, ficará aparecendo "alert-undefined", ou seja, valor 
  indefinido.

  Para isso iremos fazer utilização do "computed".

  Na tag "template" agora ficará assim:

	<div :class="baseClass">
	  Seu formulário foi enviado com sucesso!
	</div>

  Na tag "script" ficará assim:

	<script>
	export default {
	  props: ['variant'],
	  computed: {
	    baseClass() {
	      return [
	        'alert',
	        this.variant ? `alert-${this.variant}` : ``
	      ]
	    }
	  }
	}
	</script>


  Ou seja, no valor da classe que tinhamos aquela instrução toda, agora temos uma função vinda de 
  "computed".

  A função criada é "baseClass()", que retornará a mesma instrução que havia anteriormente só que antes 
  estava setada dentro da classe. Ou seja:

	:class="`alert alert-${variant}`"

  Disso acima foi para:

        this.variant ? `alert-${this.variant}` : ``

  Claramente adaptada para função funcionar corretamente. Agora temos o código ainda mais limpo, indentado 
  e feito sob boas práticas de codificação, sem contar que é uma forma bem mais inteligente de escrever 
  o código.

  Lembrando que fizemos a exemplificação aqui de apenas um "props", que colocamos o nome de "variant", 
  mas caso precisarmos podemos criar diversas outras "props".

---------------------------------------------------------------------------------------------------

  Qual a diferença de "props" e "slot"?

  "props" é mais para trabalharmos com o comportamento do componente e "slot" para trabalhar com o 
  conteúdo.

  Ou seja, "props" é o comportamento e "slot" o conteúdo. De uma maneira mais fácil de entender, "props", 
  para se ter uma semântica melhor, utilizaremos como propriedades da tag, exemplo:

	<div :class="props"></div>

  Já o "slot" utilizaremos como valor empregado, ou conteúdo:

	<div>
	  slot
	</div>

  Pois utilizando assim teremos uma melhor semântica no código e muito mais proveito também.

---------------------------------------------------------------------------------------------------

  Só nessa aula já misturamos então:

	props
	computed
	slot
	bind
	scoped

---------------------------------------------------------------------------------------------------

  Além dessa forma que vimos para declaração da "props" temos outra forma de declará-la também:

  Declaração que fizemos anteriormente:

	export default {
	  props: ['variant', 'test']
	}

  Temos essa maneira de declarar também;

	export default {
	  props: {
	    variant: {
	      type: String,
	      default: ''
	    },
	    test: {
	      type: String,
	      default: 'test'
	    }
	  }
	}

  Ou seja, nesse caso temos de declarar qual o tipo dela "type" e o valor padrão dela "default", que pode 
  ser vazio também.

  Os tipos podem ser "String", "Object", "Array", etc. 

  Porém o "Vue.js" reclama que o valor "default" para o tipo "Object" deve ser uma função, teríamos de 
  fazer da seguinte forma:

	test: {
	  type: Object,
	  default: () => {
	    return {}
	  }
	}

  Ou seja, teríamos de criar uma "arrow function" para o valor "default" retornando o objeto.

  Se for um Array basta mudarmos o retorno de objeto, no caso acima, para array, exemplo:

	test: {
	  type: Array,
	  default: () => {
	    return []
	  }
	}

  Por fim, você escolhe a forma como quer tratar a "props" pode ser daquela primeira forma, utilizando do 
  array para setar os valores, como foi nos exemplos lá no começo dessa aula, ou atráves de objeto, como o 
  foi nesses últimos exemplos citados.

  A diferença de um para outro é que na forma de declaração com o objeto a "props" fica bem mais 
  detalhada não deixando dúvidas no nosso código.

Aula 16: ==================================================================================================

Enviando Dados do Filho Para o Pai (emit):

  O "$emit()" é a função que irá enviar o evento para o componente pai.

	this.$emit( 'close' );

---------------------------------------------------------------------------------------------------

Sobre a hierarquia:

  A hierarquia de pai para filho, e assim por diante, exemplo:

	PAI > FILHO > NETO > ...

  Sempre um tratando com o seguinte, ou anterior. Exemplo, o componente PAI vai tratar com o componente 
  FILHO, assim como o componente FILHO pode tratar com o componente PAI também. Agora, o componente FILHO 
  será pai do componente NETO, assim como o componente NETO será filho do componente FILHO. Ou seja, 
  seguindo uma hierarquia familiar.

  Para tratar de componente pai para filho utilizamos a "props".

  Para tratar de componente filho para pai, utilizamos o "emit" (event).

Aula 17: ==================================================================================================

Introdução ao Vue Router:

  Documentação:

	https://router.vuejs.org/guide/

  Vue Router é o roteador oficial para Vue.js. Ele se integra profundamente com o núcleo do Vue.js para 
  facilitar a criação de aplicativos de página única com o Vue.js.

---------------------------------------------------------------------------------------------------

Instalação:

  Já que estamos com um projeto Vue.js 3 instalado via CLI, iremos instalar o Vue Router via CLI também.

  Lembrando que quando já temos um projeto rodando, temos que fazer a instalação do Vue Router 
  manualmente, e não sabendo fazer isso manualmente pode dar conflito.

	vue add router

	> Use history mode for router? no

---------------------------------------------------------------------------------------------------

History Mode:

  O "history mode" é o modo de histórico do navegador, temos o "Hash Mode" ou o "HTML5 Mode", a diferença 
  é que no "Hash Mode" temos a presença de um "#" na URL, enquanto na "HTML5 Mode" não, porém no "HTML5 
  Mode" temos que configurar o servidor para a URL amigável.

  Por padrão, quando instalamos o "Vue Router" por CLI, ele vem com o "Hash Mode".

  Para mudarmos isso, iremos na pasta "router" em "index.js" e mudaremos o:

	createWebHashHistory

  Para:

	createWebHistory

  Existe um dele no "import" e outro na "const" chamada "router" no final do arquivo. Assim a URL não 
  apresentará mais a "#" conforme navegar entre as páginas.

---------------------------------------------------------------------------------------------------

Arquivos e pastas após instalação:

  - Na pasta "Package.json", vemos que ele instalou o:

	"vue-router": "^4.0.3"

  E temos também:

	"@vue/cli-plugin-router": "~5.0.0",

  - Em "main.js" vemos que ele importou:

	import router from './router'

  Foi instanciado também:

	window.app = createApp(App).use(router).mount('#app')

  - Foi criada a pasta "router" com o arquivo "index.js", esse arquivo é onde fica as configurações do 
  nosso roteador.

  Dentro desse arquivo temos as "routes", que nada mais é do que as rotas, instanciada cada uma dentro de 
  um objeto, exemplo:

	{
	  path: '/',
	  name: 'home',
	  component: HomeView
	}

  Dessa forma é carregado o componente já diretamente.

  Além dessa forma exemplificada acima, existe uma outra forma de instanciar uma rota:

	{
	  path: '/about',
	  name: 'about',
	  component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue')
	}

  Essa segunda forma é a mais indicada para se utilizar pois ela faz um processamento mais lento, ou seja, 
  só irá carregar o componente quando você visitar ele, poupando assim memória, o chamada "lazy-loaded".

  - Foi criada uma outra pasta chamada "views", com dois arquivos para exemplificar, "AboutView.vue" e 
  HomeView.vue

---------------------------------------------------------------------------------------------------

Continuação:

  Em "App.vue", foi setado dois "router-link" dentro da tag "template", referentes aos dois arquivos, 
  "AboutView.vue" e "HomeView.vue", e para que funcionem é necessário utilizar:

	<router-view/>

  Para criar uma nova rota é a mesma coisa explicada anterior, siga os seguintes passos:

  Dentro do arquivo "index.js", na pasta "router":

	{
	  path: '/servicos',
	  name: 'Serviços',
	  component: () => import('../views/ServicesView.vue')
	}

  Dentro de "App.vue" vamos adicionar o link:

	<router-link to="/servicos">Serviços</router-link>

---------------------------------------------------------------------------------------------------

Rota dinâmica:

  Podemos passar o link da rota dinamicamente:

	<RouterLink :to="rotaDinamica">Serviços</RouterLink>

  Acima, utilizamos o "bind" e uma variável dentro da tag "template" em "App.vue".

  Na tag "script":

	<script>
	  export default {
	    data() {
	      return {
	        rotaDinamica: 'servicos'
	      }
	    }
	  }
	
	</script>

  Lembrando que lá me "index.js" temos de ter a rota adicionada também:

	{
	  path: '/servicos',
	  name: 'Serviços',
	  component: () => import('../views/ServicesView.vue')
	}

---------------------------------------------------------------------------------------------------

"Kebab Case" e "Pascal Case":

  Caso não tenha percebido anterior, quando terminamos de instalar o "Vue Router" as rotas são setadas 
  dessa seguinte forma:

	<router-link to="/servicos">Serviços</router-link>

  Me refiro na forma de setar a tag, é chamada de "Kebab Case". Existe uma melhor forma de fazer isso:

  O <PascalCase/> é mais fácil de ler porque torna muito óbvio o que é um componente vue e o que é uma 
  marcação HTML regular.

  O <kebab-case/> é mais uniforme e bonito, mas é um pouco mais difícil ver rapidamente quais elementos 
  são componentes vue e quais são HTML regular. 

  Caso for iniciar um novo projeto sozinho, utilize <PascalCase/>, mas lembresse que usar o <kebab-case/> 
  não é um problema.

---------------------------------------------------------------------------------------------------

Capturar ID:

  Primeiro criaremos a rota. Indo na pasta "router" em "index.js", criaremos o "path":

	{
	  path: '/usuarios/:id',
	  name: 'usuarios-editar',
	  component: () => import(../views/UserEditView.vue)
	}

  Obviamente agora criaremos um arquivo dentro da pasta "views" chamado "UserEditView.vue". Não precisamos 
  criar muita coisa dentro desse arquivo, somente algo para exemplificar:

	<template>
	  <div>
	    Usuário
	  </div>
	</template>

  Agora, para conseguirmos acessar, iremos no arquivo pai "App.vue" e instaciaremos a rota:

	<RouterLink to="/usuario/10">Usuário</RouterLink>

---------------------------------------------------------------------------------------------------

Objeto "route" e "router":

  Quando temos acesso ao "Vue Router", temos acesso então ao:

	<pre>
	  {{ $route }}
	</pre>

  A tag "pre" no HTML é utilizada para representar texto pré-formatado. Aqui queremos mostrar o "$route".

  Esse objeto "$route" nos traz muitas informações sobre a rota atual que é de grande valia pois podemos 
  utilizá-las. Exemplo:

	<div>
	  {{ $route.params.id }}
	</div>

  Isso nos traria o ID do usuário atual. Outro exemplo:

	<div>
	  {{ $route.query.page }}
	</div>

  Isso nos traria a página atual em que o usuário atual está. E assim por diante.

  Podemos utilizar esse objeto também dentro da tag "script":

	<script>
	  export default {
	    created() {
	      console.log( this.$route );
	    }
	  }
	</script>

  Existe também outro objeto que temos acesso, o "$router".

  A diferença entre os dois é que o "$router" tem funcionalidades do esquema de roteamento e o "$route" 
  tem traços da rota atual.

Aula 19: ==================================================================================================

VUEX (State):

  